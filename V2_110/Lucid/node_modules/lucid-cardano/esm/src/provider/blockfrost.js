import { C } from "../core/mod.js";
import { fromHex, toHex } from "../utils/mod.js";
export class Blockfrost {
    constructor(url, projectId) {
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = { url, projectId };
    }
    async getProtocolParameters() {
        const result = await fetch(`${this.data.url}/epochs/latest/parameters`, {
            headers: { project_id: this.data.projectId },
        }).then((res) => res.json());
        return {
            minFeeA: parseInt(result.min_fee_a),
            minFeeB: parseInt(result.min_fee_b),
            maxTxSize: parseInt(result.max_tx_size),
            maxValSize: parseInt(result.max_val_size),
            keyDeposit: BigInt(result.key_deposit),
            poolDeposit: BigInt(result.pool_deposit),
            priceMem: parseFloat(result.price_mem),
            priceStep: parseFloat(result.price_step),
            maxTxExMem: BigInt(result.max_tx_ex_mem),
            maxTxExSteps: BigInt(result.max_tx_ex_steps),
            coinsPerUtxoByte: BigInt(result.coins_per_utxo_size),
            collateralPercentage: parseInt(result.collateral_percent),
            maxCollateralInputs: parseInt(result.max_collateral_inputs),
            costModels: result.cost_models,
        };
    }
    async getUtxos(address) {
        let result = [];
        let page = 1;
        while (true) {
            const pageResult = await fetch(`${this.data.url}/addresses/${address}/utxos?page=${page}`, { headers: { project_id: this.data.projectId } }).then((res) => res.json());
            if (pageResult.error) {
                if (pageResult.status_code === 404) {
                    return [];
                }
                else {
                    throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
                }
            }
            result = result.concat(pageResult);
            if (pageResult.length <= 0)
                break;
            page++;
        }
        return this.blockfrostUtxosToUtxos(result.map((r) => ({ ...r, address })));
    }
    async getUtxosWithUnit(address, unit) {
        let result = [];
        let page = 1;
        while (true) {
            const pageResult = await fetch(`${this.data.url}/addresses/${address}/utxos/${unit}?page=${page}`, { headers: { project_id: this.data.projectId } }).then((res) => res.json());
            if (pageResult.error) {
                if (pageResult.status_code === 404) {
                    return [];
                }
                else {
                    throw new Error("Could not fetch UTxOs from Blockfrost. Try again.");
                }
            }
            result = result.concat(pageResult);
            if (pageResult.length <= 0)
                break;
            page++;
        }
        return this.blockfrostUtxosToUtxos(result.map((r) => ({ ...r, address })));
    }
    async getUtxosByOutRef(outRefs) {
        const queryHashes = [...new Set(outRefs.map((outRef) => outRef.txHash))];
        const utxos = await Promise.all(queryHashes.map(async (txHash) => {
            const result = await fetch(`${this.data.url}/txs/${txHash}/utxos`, { headers: { project_id: this.data.projectId } }).then((res) => res.json());
            if (!result || result.error) {
                return [];
            }
            const utxosResult = result.outputs.map((
            // deno-lint-ignore no-explicit-any
            r) => ({
                ...r,
                tx_hash: txHash,
            }));
            return this.blockfrostUtxosToUtxos(utxosResult);
        }));
        return utxos.reduce((acc, utxos) => acc.concat(utxos), []).filter((utxo) => outRefs.some((outRef) => utxo.txHash === outRef.txHash && utxo.outputIndex === outRef.outputIndex));
    }
    async getDelegation(rewardAddress) {
        const result = await fetch(`${this.data.url}/accounts/${rewardAddress}`, { headers: { project_id: this.data.projectId } }).then((res) => res.json());
        if (!result || result.error) {
            return { poolId: null, rewards: 0n };
        }
        return {
            poolId: result.pool_id || null,
            rewards: BigInt(result.withdrawable_amount),
        };
    }
    async getDatum(datumHash) {
        const datum = await fetch(`${this.data.url}/scripts/datum/${datumHash}/cbor`, {
            headers: { project_id: this.data.projectId },
        })
            .then((res) => res.json())
            .then((res) => res.cbor);
        if (!datum || datum.error) {
            throw new Error(`No datum found for datum hash: ${datumHash}`);
        }
        return datum;
    }
    async awaitTx(txHash) {
        return await new Promise((res) => {
            const confirmation = setInterval(async () => {
                const isConfirmed = await fetch(`${this.data.url}/txs/${txHash}`, {
                    headers: { project_id: this.data.projectId },
                }).then((res) => res.json());
                if (isConfirmed && !isConfirmed.error) {
                    clearInterval(confirmation);
                    res(true);
                    return;
                }
            }, 3000);
        });
    }
    async submitTx(tx) {
        const result = await fetch(`${this.data.url}/tx/submit`, {
            method: "POST",
            headers: {
                "Content-Type": "application/cbor",
                project_id: this.data.projectId,
            },
            body: fromHex(tx),
        }).then((res) => res.json());
        if (!result || result.error) {
            if (result?.status_code === 400)
                throw new Error(result.message);
            else
                throw new Error("Could not submit transaction.");
        }
        return result;
    }
    async blockfrostUtxosToUtxos(result) {
        return (await Promise.all(result.map(async (r) => ({
            txHash: r.tx_hash,
            outputIndex: r.output_index,
            assets: (() => {
                const a = {};
                r.amount.forEach((am) => {
                    a[am.unit] = BigInt(am.quantity);
                });
                return a;
            })(),
            address: r.address,
            datumHash: !r.inline_datum ? r.data_hash : null,
            datum: r.inline_datum,
            scriptRef: r.reference_script_hash &&
                (await (async () => {
                    const { type, } = await fetch(`${this.data.url}/scripts/${r.reference_script_hash}`, {
                        headers: { project_id: this.data.projectId },
                    }).then((res) => res.json());
                    // TODO: support native scripts
                    if (type === "Native") {
                        throw new Error("Native script ref not implemented!");
                    }
                    const { cbor } = await fetch(`${this.data.url}/scripts/${r.reference_script_hash}/cbor`, { headers: { project_id: this.data.projectId } }).then((res) => res.json());
                    const script = C.PlutusScript.new(fromHex(cbor));
                    const scriptRef = C.ScriptRef.new(type === "PlutusV1"
                        ? C.Script.new_plutus_v1(script)
                        : C.Script.new_plutus_v2(script));
                    return toHex(scriptRef.to_bytes());
                })()),
        }))));
    }
}
/**
 * This function is temporarily needed only, until Blockfrost returns the datum natively in Cbor.
 * The conversion is ambigious, that's why it's better to get the datum directly in Cbor.
 */
export function datumJsonToCbor(json) {
    const convert = (json) => {
        if (!isNaN(json.int)) {
            return C.PlutusData.new_integer(C.BigInt.from_str(json.int.toString()));
        }
        else if (json.bytes || !isNaN(Number(json.bytes))) {
            return C.PlutusData.new_bytes(fromHex(json.bytes));
        }
        else if (json.map) {
            const m = C.PlutusMap.new();
            json.map.forEach(({ k, v }) => {
                m.insert(convert(k), convert(v));
            });
            return C.PlutusData.new_map(m);
        }
        else if (json.list) {
            const l = C.PlutusList.new();
            json.list.forEach((v) => {
                l.add(convert(v));
            });
            return C.PlutusData.new_list(l);
        }
        else if (!isNaN(json.constructor)) {
            const l = C.PlutusList.new();
            json.fields.forEach((v) => {
                l.add(convert(v));
            });
            return C.PlutusData.new_constr_plutus_data(C.ConstrPlutusData.new(C.BigNum.from_str(json.constructor.toString()), l));
        }
        throw new Error("Unsupported type");
    };
    return toHex(convert(json).to_bytes());
}
